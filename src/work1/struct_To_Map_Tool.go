package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	//以逗号分隔的类型名称列表;type必须设定
	structNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output      = flag.String("output", "", "output file name; default srcdir/<type>_toolMethodTool.go")
	path        = flag.String("path", "", "find directory, default to current location")
)

type packageInfo struct {
	Structs  []*result
	PkgPath  string
	astFiles []*ast.File
}
type result struct {
	StructName string
	FieldNames []string
}

func main() {
	//命令行解析
	{
		log.SetPrefix("structToMap: ") // log output Prefix
		flag.Usage = Usage             //使用自定义Usage替换默认提示
		flag.Parse()                   //解析命令行参数
		if len(*structNames) == 0 {
			//无type参数，给出提示，退出程序
			flag.Usage()
			os.Exit(2)
		}
	}

	//多个type参数时进行分割（window中用“”）
	var types, paths []string
	{
		types = strings.Split(*structNames, ",")
		paths = strings.Split(*path, ",")
		if len(*path) == 0 {
			paths = []string{"."} //default：处理当前目录中的整个包。
		}
	}

	var allDirs []string
	{
		//判断路径的正确性以及转为绝对路径
		for i := range paths {
			if isDirectory(paths[i]) {
				if !filepath.IsAbs(paths[i]) {
					var err error
					paths[i], err = filepath.Abs(paths[i])
					if err != nil {
						log.Fatal(err, "构建绝对路径出错")
					}
				}
			}
		}
		//获取所有的子目录
		for i := range paths {
			//遍历获取子目录
			dirs, err := getAllSonDirs(paths[i])
			if err != nil {
				log.Fatal("getAllSonDirs:", err)
			}
			allDirs = append(allDirs, dirs...)
		}
	}

	var allInfo []*packageInfo
	{
		cfg := &packages.Config{
			Mode: packages.LoadSyntax, //不包含依赖,尝试下面这个
		}
		pkginfos, err := packages.Load(cfg, allDirs...)
		if err != nil {
			log.Fatal("package.Load:", err)
		}
		for ix := range allDirs {
			pkg := pkginfos[ix]
			astFiles := make([]*ast.File, len(pkg.Syntax))
			for i, file := range pkg.Syntax {
				astFiles[i] = file
			}
			p := packageInfo{
				astFiles: astFiles,
				PkgPath:  pkg.PkgPath,
			}
			allInfo = append(allInfo, &p)
		}
	}

	//将每个type都放到多个目录中去查找一次
	{
		for _, typeName := range types {
			for _, packageinfo := range allInfo {
				packageinfo.findNodeOnAst(typeName)
			}
		}
	}

	//筛选有结果的包
	var resultInfo []*packageInfo
	{
		for _, info := range allInfo {
			if len(info.Structs) > 0 {
				resultInfo = append(resultInfo, info)
			}
		}
		if len(resultInfo) == 0 {
			log.Fatal("没有查找到满足条件的结构体")
		}
	}
	//var buf bytes.Buffer
	buf := bytes.Buffer{}
	{
		// Print the header and package clause.
		_, _ = fmt.Fprintf(&buf, "// Scry Info.  All rights reserved.\n")
		_, _ = fmt.Fprintf(&buf, "// license that can be found in the license file.\n")
		_, _ = fmt.Fprintf(&buf, "// Code generated by \"structToMap %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
		_, _ = fmt.Fprintf(&buf, "package main\n")
		t, err := template.ParseFiles("file1.tmpl")
		if err != nil {
			log.Println("parseFileErr:", err)
		}
		err = t.Execute(&buf, resultInfo)
		if err != nil {
			log.Println("executing template:", err)
		}

	}

	// Write to file.
	{
		outputName := *output
		if outputName == "" {
			baseName := fmt.Sprintf("%sToMap.go", strings.ToLower(types[0]))
			outputName = filepath.Join(".", baseName)
		} else {
			baseName := outputName + ".go"
			outputName = filepath.Join(".", baseName)
		}
		err := ioutil.WriteFile(outputName, buf.Bytes(), 0644)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}

//自定义使用提示
func Usage() {
	_, _ = fmt.Fprintf(os.Stderr, "Usage of structToMap:\n")
	_, _ = fmt.Fprintf(os.Stderr, "\tstructToMapTool [flags] -type=T... \n\t# Must be a single package\n")
	_, _ = fmt.Fprintf(os.Stderr, "For more information, see:\n")
	_, _ = fmt.Fprintf(os.Stderr, "\thttps://www.jianshu.com/p/879edba89c72\n")
	_, _ = fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults() //print flags
}

//判断其指定的文件是否是目录
func isDirectory(name string) bool {
	info, err := os.Stat(name) //return fileinfo
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir() //true or false
}

//查找结构体并构建生成的方法
func (g *packageInfo) findNodeOnAst(typeName string) {
	oneStruct := &result{}
	for _, astfile := range g.astFiles { //range all *ast.file
		if astfile == nil {
			break
		}
		ast.Inspect(astfile, func(node ast.Node) bool {
			for {
				//select correct node
				ret, ok := node.(*ast.TypeSpec)
				if !ok {
					break
				}
				x, ok2 := (ret.Type).(*ast.StructType)
				if !ok2 {
					break
				}
				if ret.Name.Name != typeName {
					break
				}
				a := x.Fields.List //[]*Field
				oneStruct.StructName = typeName
				for _, fielddata := range a { //a is sturuct fileds
					for _, j := range fielddata.Names { //name is i []  ??
						oneStruct.FieldNames = append(oneStruct.FieldNames, j.Name)
					}
					//匿名字段
					if fielddata.Names == nil {
						data := (fielddata.Type).(*ast.Ident)
						oneStruct.FieldNames = append(oneStruct.FieldNames, data.Name)
					}
				}
				g.Structs = append(g.Structs, oneStruct)
				return false //同包内不能定义相同的结构体
			}
			return true
		})
	}
}

//获取指定目录下的所有子目录
func getAllSonDirs(dirpath string) ([]string, error) {
	var dir_list []string
	dir_err := filepath.Walk(dirpath,
		func(path string, f os.FileInfo, err error) error {
			if f == nil {
				return err
			}
			if f.IsDir() {
				dir_list = append(dir_list, path)
				return nil
			}
			return nil
		})
	return dir_list, dir_err
}
