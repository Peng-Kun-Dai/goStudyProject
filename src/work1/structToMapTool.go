package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	//以逗号分隔的类型名称列表;type必须设定
	structNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output      = flag.String("output", "", "output file name; default srcdir/<type>_toolMethodTool.go")
	path        = flag.String("path", "", "find directory, default to current location")
)

//生成器
type Generator struct {
	buf         bytes.Buffer
	packageName string //正在扫描的包名
	astFiles    []*ast.File
	StructName  string
	FieldsNames []string
}

func main() {
	log.SetPrefix("structToMap: ") // log output Prefix
	flag.Usage = Usage             //使用自定义Usage替换默认提示
	flag.Parse()                   //解析命令行参数
	if len(*structNames) == 0 {
		//无type参数，给出提示，退出程序
		flag.Usage()
		os.Exit(2)
	}
	//多个type参数时进行分割（window中用“”）
	var types = strings.Split(*structNames, ",")
	var paths = strings.Split(*path, ",")
	if len(*path) == 0 {
		paths = []string{"."} //default：处理当前目录中的整个包。
	}
	var dir string
	//只处理一个目录，且该目录必须存在
	if isDirectory(paths[0]) {
		dir = paths[0]
	}
	//创建一个生成器实例
	g := Generator{}
	//向实例中添加包信息以及该目录中的文件信息
	g.parsePackage(dir)

	// Print the header and package clause.
	_, _ = fmt.Fprintf(&g.buf, "// Scry Info.  All rights reserved.\n")
	_, _ = fmt.Fprintf(&g.buf, "// license that can be found in the license file.\n")
	_, _ = fmt.Fprintf(&g.buf, "// Code generated by \"structToMap %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	_, _ = fmt.Fprintf(&g.buf, "package %s\n", g.packageName)

	for _, typeName := range types {
		g.findNodeOnAst(typeName)
	}
	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%sToMap.go", strings.ToLower(types[0]))
		outputName = filepath.Join(dir, baseName)
	} else {
		baseName := outputName + ".go"
		outputName = filepath.Join(dir, baseName)
	}
	err := ioutil.WriteFile(outputName, g.buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}

}

//自定义使用提示
func Usage() {
	_, _ = fmt.Fprintf(os.Stderr, "Usage of structToMap:\n")
	_, _ = fmt.Fprintf(os.Stderr, "\tstructToMapTool [flags] -type=T... \n\t# Must be a single package\n")
	_, _ = fmt.Fprintf(os.Stderr, "For more information, see:\n")
	_, _ = fmt.Fprintf(os.Stderr, "\thttps://www.jianshu.com/p/879edba89c72\n")
	_, _ = fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults() //print flags
}

//判断其指定的文件是否是目录
func isDirectory(name string) bool {
	info, err := os.Stat(name) //return fileinfo
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir() //true or false
}

//解析当前package
func (g *Generator) parsePackage(patterns string) {
	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
	}
	pkginfos, err := packages.Load(cfg, patterns)
	if err != nil {
		log.Fatal(err)
	}
	g.addPackageInfo(pkginfos[0])
}

//将包信息以及语法树文件放入实例中
func (g *Generator) addPackageInfo(pkg *packages.Package) {
	g.packageName = pkg.Name
	g.astFiles = make([]*ast.File, len(pkg.Syntax))
	for i, file := range pkg.Syntax {
		g.astFiles[i] = file
	}
}

//查找结构体并构建生成的方法
func (g *Generator) findNodeOnAst(typeName string) {
	var fieldNames []string
	for _, astfile := range g.astFiles { //range all *ast.file
		if astfile == nil {
			break
		}
		ast.Inspect(astfile, func(node ast.Node) bool {
			for {
				//select correct node
				ret, ok := node.(*ast.TypeSpec)
				if !ok {
					break
				}
				x, ok2 := (ret.Type).(*ast.StructType)
				if !ok2 {
					break
				}
				if ret.Name.Name != typeName {
					break
				}
				a := x.Fields.List            //[]*Field
				for _, fielddata := range a { //a is sturuct fileds
					var fieldname string
					for _, j := range fielddata.Names { //name is i []  ??
						fieldname = j.Name
						fieldNames = append(fieldNames, fieldname)
					}
					//匿名字段
					if fielddata.Names == nil {
						data := (fielddata.Type).(*ast.Ident)
						fieldNames = append(fieldNames, data.Name)
					}
				}
				g.StructName = typeName
				g.FieldsNames = fieldNames
				return false
			}
			return true
		})
	}
	if len(fieldNames) == 0 {
		//不存在或者为空结构体
		log.Fatalf("no values defined for type %s or empty struct", typeName)
	}
	g.buildCodeFromTemplate()
}

//parse template file
func (g *Generator) buildCodeFromTemplate() {
	t, err := template.ParseFiles("file1.tmpl")
	if err != nil {
		log.Println("parseFileErr:", err)
	}
	err = t.Execute(&g.buf, g)
	if err != nil {
		log.Println("executing template:", err)
	}
}
